---
layout: post
title:  "AfricaHackon Finals"
date: 2021-11-06 09:25:47 -0300  
tags: [writeup, ctf, crypto, reverse, pwn]

categories: Writeup
use math: false
preview: AfricaHackon Finals

---

## Intro

Yesterday (05/11/2021) I was taking part (as a guest) at the Africahackon finals along with some teammates of the Fr334aks team. Playing under the name `Batata`, we managed to get the first spot, solving most of the challenges, some of which had only one solve and as such I decided to make some writeups on the challs I solved.

## Cryptoo

This challenge was interesting for it envolved RSA with an even public exponent, which is something I'm not very familiar with. We were given a Python script with the following code:

```python
from Crypto.Util.number import getPrime, inverse, bytes_to_long

e = 1440

p = getPrime(1024)
q = getPrime(1024)
n = p * q

flag = b"ah{xxxxxxxxxxxxxxxxxxxx}"
c = pow(bytes_to_long(flag), e, n)

print(f"e = {e}")
print(f"p = {p}")
print(f"q = {q}")
print(f"c = {c}")

"""
e = 1440
p = 162978700629210295810649391719586503025671079350063173587722761832592228785617671514944077671114932617659575380579714162010543696149152442401177146829272429511066079301906198033364173529447978503921827642242019971331210477342321193894140447666224793264721574118325733656155304155684082750815667730540243960559
q = 130285572065962327569919536176694744820493645597821663155020747573340254381219937626501795225368224038829088518417583768608126274355275988299414360689255470016687369426125250899105732280369295580190147225308718970324176782395390204057596346288043949701881716388921305204781566634663039054898992062520177422101
c = 14204665238020554114475628327984073221787034724332448717363393031578409722000649641437079153251934422919452050163136017361707938959690120573061829917618824742827162513411812087878703014480053438572831162426517450181059504845411713094485467757528191039101896977879751831110230798672128651365474200057717303162203591331166448004522319859362013143568986153939533288130683189735936454601862218690741979122415557852701109174160860839151042293108263280431615986660884292407738203044490728282085387662687502499545671258808565310082341540716184255392455439646134568896807531027143059203312472722000907457839879721121544714480

"""
```

### Hippity hoppity, your code is now my property

After struggling a little bit with this challenge, I did the sensible thing and searched online for similar challenges and a found a [writeup](https://angmar2722.github.io/CTFwriteups/2021/buckeye2021/#defective-rsa) that presented an interesting solution using [Roots of Unity modulus n](https://en.wikipedia.org/wiki/Root_of_unity_modulo_n) to solve a similar problem.

So I based myself on the presented algorithm (stole the code) to write the following solution:

```python
from Crypto.Util.number import *
from math import gcd

e = 1440
p = 162978700629210295810649391719586503025671079350063173587722761832592228785617671514944077671114932617659575380579714162010543696149152442401177146829272429511066079301906198033364173529447978503921827642242019971331210477342321193894140447666224793264721574118325733656155304155684082750815667730540243960559
q = 130285572065962327569919536176694744820493645597821663155020747573340254381219937626501795225368224038829088518417583768608126274355275988299414360689255470016687369426125250899105732280369295580190147225308718970324176782395390204057596346288043949701881716388921305204781566634663039054898992062520177422101
ct = 14204665238020554114475628327984073221787034724332448717363393031578409722000649641437079153251934422919452050163136017361707938959690120573061829917618824742827162513411812087878703014480053438572831162426517450181059504845411713094485467757528191039101896977879751831110230798672128651365474200057717303162203591331166448004522319859362013143568986153939533288130683189735936454601862218690741979122415557852701109174160860839151042293108263280431615986660884292407738203044490728282085387662687502499545671258808565310082341540716184255392455439646134568896807531027143059203312472722000907457839879721121544714480
n = p * q

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


def roots_of_unity(e, phi, n, rounds=250):
    phi_coprime = phi
    while gcd(phi_coprime, e) != 1:
        phi_coprime //= gcd(phi_coprime, e)

    roots = set(pow(i, phi_coprime, n) for i in range(1, rounds))
    return roots, phi_coprime

phi = (p - 1) * (q - 1)

roots, phi_coprime = roots_of_unity(e, phi, n)

d = modinv(e, phi_coprime)
pt = pow(ct, d, n)

pts = [(pt * root) % n for root in roots]
pts = [long_to_bytes(pt) for pt in pts]

for possibleFlag in pts:
    if b'ah{' in possibleFlag:
        print(possibleFlag)
        exit()
```

## iamfree


For this challenge we were given a LSB executable and access to a ssh server. On the server we had the flag, which was owned by root and the same executable file which had the SUID bit set, so it became clear that the goal was to exploit this program to read the flag.

I started by opening the file on Ghidra to see what I was dealing with. The program's main was decompiled to the following code:

```c
undefined4 main(void)

{
  int *__s;
  void *local_1c;
  
  setuid(0);
  __s = (int *)malloc(0x10);
  puts("Let play a game of chess");
  do {
    while( true ) {
      while( true ) {
        while( true ) {
          printf("Make your move : ");
          fgets((char *)__s,0x11,stdin);
          if (((*__s != 0x46524545) || (__s[1] != 0x71756565)) || (__s[2] != 0x6e333e3a)) break;
          free(local_1c);
          puts("Nice move. I can\'t catchup");
        }
        if (((*__s != 0x4e455721) || (__s[1] != 0x4b494e47)) || ((char)(__s[2] << 2) != -4)) break;
        local_1c = malloc(0x10);
        *(int *)((int)local_1c + 0xc) = __s[3];
        puts("King placed in order");
      }
      if (((*__s == 0x75733334) && (__s[1] == 0x66743352)) && (__s[2] == 0x66523333)) break;
      puts("Wrong move");
    }
    puts("Brilliant. One last Move");
  } while ((*(uint *)((int)local_1c + 0xc) & 0xff) != 0x37);
  system("/bin/cat flag");
  return 0;
}

```

As you can see, this code is not very clear, but can still figure what it is doing. It works like a game of chess in which we are supposed to enter our move and the program will process it to some extend, and eventually execute a command to read the flag under some specific conditions.

There are four loops that we need to break out of to reach the point where the flag is read. We can see that at each iteration, our input is processed as integer values and compared with some hard-coded constants.

To break out of the inner-most loop, our input must not have 0x46524545 as the first four bytes, or 0x71756565 as the second four bytes, or 0x6e333e3a as the last four bytes. What means we need to avoid the string "FREEqueen3>:", that because of the byte order (little-endian) is actually written as "EERFeeuq:>3n".

Next, to break out of the second loop, we need our input to differ from the values 0x4e455721, 0x4b494e47, and some other value that whose last byte multiplied by 4 is equal to -4. That would be a string like "!WENGNIK?AAA7" (already considering the little-endian).
To break out of the next loop, our input must match the values 0x75733334, 0x66743352 and 0x66523333, which forms the string "fR33ft3Rus34" or "43suR3tf33Rf" in little-endian.

Finally, to break out of the last loop, the value of the last byte stored at the address local_1c + 0xc (as local_1c is a pointer, this would be like indexing an array to access the 12th position) must be equal to 0x37 (char 55, which is the number '7'). Looking through the code we can see that this value is set as the last part of our input on the second loop if we don't break out of it immediately.

So, first we need to break out of the first (inner-most) loop by providing any input different of "EERFeeuq:>3n", reaching the second loop where we should stay for one iteration in order to set the value at local_1c + 0xc to 55. Next, we break out of this second loop and also from the third loop by providing the string "43suR3tf33Rf" as input.

Putting it all together, our input should be something like "!WENGNIK?XXX7XXX43suR3tf33Rf". So, my final "exploit" consisted of this one-liner:

```bash
echo '!WENGNIK?XXX7XXX43suR3tf33Rf' | ./iamfree
```

## NameCheck

For this challenge we were given another ELF executable and access to a server through SSH. To read the flag, we need to exploit two different vulnerabilities on the given program. The program reads a name from stdin and stores it in a 400 bytes buffer which is then validated in the parseName() function which verifies if the input name has less than 21 bytes and then copies it to another buffer.

The first vulnerabilty we need to exploit is a buffer overflow which occurs when the input names are validated and copied to a smaller buffer, however because of the length limit we need to chain this vulnerability with a second vulnerability to successfully exploit it.

Looking through the decompiled binary at Ghidra, we can see that when the length of the input is verified, it is stored into a char (an 8-bit signed value) which can only hold numbers in the interval -128 to 127. So, if we place an input that is big enough, the value will be processed as a negative value, making it less than the maximum size allowed.

To do so, we start with a buffer of 255 bytes which we know can bypass the validation as it is interpreted as having a length of -128, causing the buffer to be overflowed. Now we need to find where to find some address to divert the execution flow to and also the precise location of our buffer to place this address.

Again, looking through the disassebled code, we can see that there is a function called systemCheck that is never called, but when executed will run `/bin/cat flag` using the system() method, making it the perfect gadget for this exploit.

To find the target address I used the `nm` utility from binutils with the syntax `nm namecheck`, and the output tells me that the systemCheck function is at `0804859f`.  Becase the architecture is little-endian we will need to write it as `9f850408`.

Next we need to find the position of our buffer that will overflow the return address. To do this I used a [custom script](https://gist.github.com/LvMalware/7f3a9497e4d31d7948f7d47fb2d1dce1) to generate a cyclic pattern with 255 bytes to cause a crash and then find the position in the pattern where the eip address starts (which I found to be at index 36 in this case). Now we know how to bypass the validation, where to redirect the execution flow and also the position to place the address. My final exploit consisted of this one-liner:

```bash
perl -e 'print "A"x36 . "\x9f\x85\x04\x08" x 8 . "A"x200' | ./namecheck

```

When we run it, we get the flag (multiple times, actually) and the program crashes because the stack is now a mess, but the exploit was a success.


## And that's all, folks.

